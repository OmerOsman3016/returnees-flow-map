<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Head content remains unchanged -->
</head>

<body>
  <!-- Body content remains unchanged until the script section -->

  <script>
    // Initialize the map
    const map = L.map('map').setView([16, 31], L.Browser.mobile ? 3 : 5.5);

    // Define multiple base layers
    const cartoDBLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });

    const openStreetMap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });

    const esriWorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: '&copy; <a href="https://www.esri.com/">Esri</a>'
    });

    const stamenToner = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png', {
      attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>'
    });

    // Add default base layer
    cartoDBLight.addTo(map);

    // Add Sudan Admin 0 boundaries
    const admn0 = L.esri.featureLayer({
      url: "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/World_Countries/FeatureServer/0",
      where: "ISO = 'SDN'", // Filter for Sudan using ISO country code
      style: {
        color: "#0033A0", // Border color
        weight: 2, // Border thickness
        dashArray: "5, 5", // Dashed border
        fillOpacity: 0 // No fill
      }
    }).addTo(map);

    const admn1 = L.esri.featureLayer({
      url: "https://codgis.itos.uga.edu/arcgis/rest/services/COD_External/SDN_EN/MapServer/2",
      where: "ADMLEVEL = 1",
      style: {
        color: "#0033A0",
        weight: 2,
        dashArray: "2, 2"
      }
    }).addTo(map);

    const admn2 = L.esri.featureLayer({
      url: "https://codgis.itos.uga.edu/arcgis/rest/services/COD_External/SDN_EN/MapServer/2",
      where: "ADMLEVEL = 2",
      style: {
        color: "#0033A0",
        weight: 1,
        dashArray: "1, 1"
      }
    }).addTo(map);

    // Add layer control
    const baseLayers = {
      "CartoDB Light": cartoDBLight,
      "OpenStreetMap": openStreetMap,
      "Esri World Imagery": esriWorldImagery,
      "Stamen Toner": stamenToner
    };

    L.control.layers(baseLayers).addTo(map);

    // Store the flowmap layer globally
    let flowmapLayer;

    // Variable to store the total volume of returnees
    let totalVolume = 0;

    // Parse CSV data and create flow map layer
    Papa.parse('./data/data.csv', {
      download: true,
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true,
      complete: (results) => {
        const geoJsonFeatureCollection = {
          type: 'FeatureCollection',
          features: results.data.map(datum => {
            // Accumulate the total volume
            totalVolume += datum.e_Volume || 0;

            return {
              type: 'Feature',
              geometry: { type: 'Point', coordinates: [datum.s_lon, datum.s_lat] },
              properties: datum
            };
          })
        };

        // Log the total volume to the console
        console.log('Total e_volume of returnees:', totalVolume);

        flowmapLayer = L.canvasFlowmapLayer(geoJsonFeatureCollection, {
          originAndDestinationFieldIds: {
            originUniqueIdField: 's_state_id',
            originGeometry: { x: 's_lon', y: 's_lat' },
            destinationUniqueIdField: 'e_locality_id',
            destinationGeometry: { x: 'e_lon', y: 'e_lat' }
          },
          style: (feature) => {
            const baseRadius = 6;
            const maxRadius = 20;
            const volume = feature.properties.e_Volume || 0;

            const radius = feature.properties.isOrigin
              ? baseRadius
              : Math.min(baseRadius + (volume / 5000), maxRadius);

            return {
              radius: radius,
              weight: 1,
              color: feature.properties.isOrigin ? 'rgb(17, 142, 170)' : 'rgb(195, 255, 62)',
              fillColor: feature.properties.isOrigin ? 'rgba(0, 51, 160)' : 'rgb(255, 103, 31)',
              fillOpacity: feature.properties.isOrigin ? 0.8 : 0.7
            };
          },
          canvasBezierStyle: {
            type: 'classBreaks',
            field: 'e_Volume',
            classBreakInfos: [
              { classMinValue: 1, classMaxValue: 50000, symbol: { strokeStyle: '#ffb81c', lineWidth: 0.5, lineCap: 'round', shadowColor: '#fee8c8', shadowBlur: 2.0 } },
              { classMinValue: 50001, classMaxValue: 100000, symbol: { strokeStyle: '#ff671f', lineWidth: 1.5, lineCap: 'round', shadowColor: '#fdbb84', shadowBlur: 2.0 } },
              { classMinValue: 100001, classMaxValue: 200000, symbol: { strokeStyle: '#d22630', lineWidth: 3, lineCap: 'round', shadowColor: '#e34a33', shadowBlur: 2.0 } }
            ],
            defaultSymbol: { strokeStyle: '#e7e1ef', lineWidth: 0.5, lineCap: 'round', shadowColor: '#e7e1ef', shadowBlur: 1.5 }
          },
          pathDisplayMode: 'all',
          animationStarted: true,
          animationEasingFamily: 'Linear',
          animationEasingType: 'None',
          animationDuration: 3000,
          onEachFeature: addTooltip
        }).addTo(map);

        // Add tooltip and popup to features
        function addTooltip(feature, layer) {
          const tooltipContent = feature.properties.isOrigin
            ? `State of Displacement: ${feature.properties.s_State}`
            : `State of Return: ${feature.properties.e_locality}`;

          layer.bindTooltip(tooltipContent);
          layer.on('mouseover', () => layer.openTooltip());
          layer.on('mouseout', () => layer.closeTooltip());

          // Add popup
          const popupContent = feature.properties.isOrigin
            ? `<b>State of Displacement:</b> ${feature.properties.s_State}`
            : `<b>State of Return:</b> ${feature.properties.e_locality}`;

          layer.bindPopup(popupContent);
        }

        // Highlight paths on mouseover
        flowmapLayer.on('mouseover', (e) => {
          if (e.sharedOriginFeatures.length) {
            flowmapLayer.selectFeaturesForPathDisplay(e.sharedOriginFeatures, 'SELECTION_NEW');
          }
          if (e.sharedDestinationFeatures.length) {
            flowmapLayer.selectFeaturesForPathDisplay(e.sharedDestinationFeatures, 'SELECTION_NEW');
          }
        });

        // Select initial feature for path display
        flowmapLayer.selectFeaturesForPathDisplayById('s_state_id', "SD15", true, 'SELECTION_NEW');
      }
    });

    // Add legend to the map
    const legend = L.control({ position: 'bottomleft' });
    legend.onAdd = () => {
      const div = L.DomUtil.create('div', 'legend');
      div.innerHTML = `
        <div style="width:17px;height:17px;background:rgba(255, 103, 31, 0.8);float:left;margin-right:10px;border-radius:30px"></div>
        <span style="float:left;margin-top:1px;font-weight:bold">State of Return</span><br/><br/>
        <div style="width:17px;height:17px;background:rgba(0, 51, 160, 0.8);float:left;margin-right:10px;border-radius:30px"></div>
        <span style="float:left;margin-top:1px;font-weight:bold">State of Displacement </span><br/><br/>
        <span style="font-size:14px">Returnee Flow Volume:</span><br/>
        <div style="width:70px;height:3px;background:#ffb81c;float:left;margin-right:10px;margin-top:10px"></div>
        <span style="float:left;font-weight:bold"> < 50,000</span><br/>
        <div style="width:70px;height:4px;background:#ff671f;float:left;margin-right:10px;margin-top:10px"></div>
        <span style="float:left;font-weight:bold">50,001 - 100,000</span><br/>
        <div style="width:70px;height:7px;background:#e34a33;float:left;margin-right:10px;margin-top:10px"></div>
        <span style="float:left;font-weight:bold"> > 100,000</span><br/>
      `;
      return div;
    };
    legend.addTo(map);

    // Initialize Timeline Graph
    const ctx = document.getElementById('timelineChart').getContext('2d');
    const gradient = ctx.createLinearGradient(0, 0, 0, 200);
    gradient.addColorStop(0, 'rgba(0, 51, 160, 0.8)');
    gradient.addColorStop(1, 'rgba(0, 51, 160, 0.2)');

    const timelineChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: ['Dec-24', 'Jan-25', 'Feb-25', 'Mar-25', 'Apr-25', 'May-25', 'Jun-25'],
        datasets: [{
          label: 'Returnees Over Time',
          data: [8690, 94525, 177628, 0, 0, 0, 0],
          borderColor: '#0033A0',
          backgroundColor: gradient,
          borderWidth: 3,
          fill: true,
          pointBackgroundColor: '#0033A0',
          pointBorderColor: '#fff',
          pointRadius: 5,
          pointHoverRadius: 7,
          tension: 0.4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          tooltip: {
            backgroundColor: '#0033A0',
            titleColor: '#fff',
            bodyColor: '#fff',
            borderColor: '#fff',
            borderWidth: 1,
            displayColors: false
          },
          legend: {
            display: false
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: 'Number of Returnees',
              color: '#0033A0',
              font: {
                size: 14,
                weight: 'bold'
              }
            },
            grid: {
              color: '#e0e0e0'
            }
          },
          x: {
            title: {
              display: true,
              text: 'Month',
              color: '#0033A0',
              font: {
                size: 14,
                weight: 'bold'
              }
            },
            grid: {
              color: '#e0e0e0'
            }
          }
        },
        animation: {
          duration: 2000,
          easing: 'easeInOutQuart'
        }
      }
    });
  </script>
</body>

</html>
